//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : PSDE
//  @ File Name : CGeomCollection.cpp
//  @ Date : 2010/12/20
//  @ Author : 
//
//


#include "CGeomCollection.h"

namespace Geometry {
CGeomCollection::CGeomCollection() {
	mGeoms = new vector<CGeometry *> ();
}

CGeomCollection::CGeomCollection(const CGeomCollection & coll) :
	CGeometry(coll) {
	size_t n = coll.getNumGeometries();
	mGeoms = new vector<CGeometry *> (n);
	for (size_t i = 0; i < n; i++) {
		(*mGeoms)[i] = coll.getGeometryAt(i)->clone();
	}
}

CGeomCollection::CGeomCollection(vector<CGeometry *> * geoms) {
	if (geoms == NULL)
		CGeomCollection();
	else
		mGeoms = geoms;
}

CGeomCollection::~CGeomCollection() {
	for (size_t i = 0, n = mGeoms->size(); i < n; i++) {
		delete (*mGeoms)[i];
	}

	delete mGeoms;
}

CGeometry* CGeomCollection::clone() const {
	return new CGeomCollection(*this);
}

double CGeomCollection::getArea() const {
	double area = 0;
	for (size_t i = 0, n = mGeoms->size(); i < n; i++) {
		area += (*mGeoms)[i]->getArea();
	}
	return area;
}

double CGeomCollection::getLength() const {
	double length = 0;
	for (size_t i = 0, n = mGeoms->size(); i < n; i++) {
		length += (*mGeoms)[i]->getLength();
	}
	return length;
}

size_t CGeomCollection::getNumPoints() const {
	size_t ans = 0;
	for (size_t i = 0, n = mGeoms->size(); i < n; i++) {
		ans += (*mGeoms)[i]->getNumPoints();
	}
	return ans;
}

size_t CGeomCollection::getNumGeometries() const {
	return mGeoms->size();
}

CCoVecSequence *CGeomCollection::getCoordinates() const {
	return NULL;
}

bool CGeomCollection::equalExact(CGeometry* geom, double eps) const {
	if (!isEquivalentClass(geom))
		return false;
	for (size_t i = 0, n = mGeoms->size(); i < n; i++) {
		CGeometry * pa = (*mGeoms)[i];
		CGeometry * pb = (*((CGeomCollection *) geom)->mGeoms)[i];
		if (!pa->equalExact(pb, eps))
			return false;
	}
	return true;
}


const CGeometry* CGeomCollection::getGeometryAt(size_t pos) const {
	return (*mGeoms)[pos];
}

CRectangle CGeomCollection::getBoundingRect() const{
	if (mGeoms->size() == 0)
		return CRectangle();
	CRectangle rect = (*mGeoms)[0]->getBoundingRect();
	double minx = rect.minx, miny = rect.miny, maxx = rect.maxx, maxy = rect.maxy;
	for (size_t i = 0; i < mGeoms->size(); i++) {
		rect = (*mGeoms)[i]->getBoundingRect();
		minx = min(rect.minx, minx);
		miny = min(rect.miny, miny);
		maxx = max(rect.maxx, maxx);
		maxy = max(rect.maxy, maxy);
	}
	return CRectangle(minx, miny, maxx, maxy);
}

string CGeomCollection::getGeometryType() const {
	return "CGeomCollection";
}

bool CGeomCollection::isSimple() const {
	// to be done
	return true;
}

bool CGeomCollection::isEmpty() const {
	for (size_t i = 0, n = mGeoms->size(); i < n; i++) {
		if (!(*mGeoms)[i]->isEmpty())
			return false;
	}
	return true;
}

bool CGeomCollection::isValid() const {
	// to be done
	return true;
}
COpenGISType::OPENGIS_TYPE CGeomCollection::getOGISType() const {
	return COpenGISType::OGIS_GEOMCOLLECTION;
}
}
