//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : PSDE
//  @ File Name : CPoint.cpp
//  @ Date : 2010/12/20
//  @ Author : 
//
//


#include "CPoint.h"

namespace Geometry {
CPoint::CPoint() {
	mCoord = new CCoVecSequence(CCoordinate());
}

CPoint::CPoint(const CPoint & pt) :CGeometry(pt){
	mCoord = pt.mCoord->clone();
}

CPoint::CPoint(const CCoordinate & c) {
	mCoord = new CCoVecSequence(c);
}

CPoint::CPoint(const double x, const double y, const double z) {
	mCoord = new CCoVecSequence(CCoordinate(x, y, z));
}
CPoint::~CPoint() {
	delete mCoord;
}


CGeometry* CPoint::clone() const {
	return new CPoint(*this);
}

double CPoint::getArea() const {
	return 0.0;
}

double CPoint::getLength() const {
	return 0.0;
}

size_t CPoint::getNumPoints() const {
	return isEmpty() ? 0 : 1;
}
size_t CPoint::getNumGeometries() const {
	return isEmpty() ? 0 : 1;
}
CCoVecSequence *CPoint::getCoordinates() const{
	return mCoord->clone();
}

bool CPoint::equalExact(CGeometry* geom, double eps) const {
	if (!isEquivalentClass(geom))
		return false;
	bool em1 = isEmpty();
	bool em2 = geom->isEmpty();
	if (em1 != em2)
		return false;
	if (em1 && em2)
		return true;
	CPoint *pOther = dynamic_cast<CPoint *>(geom);
	return CCoordinate::equalCCoordinate(getCoordinate(), pOther->getCoordinate(), eps);
}

CCoordinate CPoint::getCoordinate() const {
	if (mCoord->isEmpty())
		return CCoordinate();
	return mCoord->getAt(0);

}

CRectangle CPoint::getBoundingRect() const{
	return mCoord->getBoundingRect();
}

string CPoint::getGeometryType() const {
	return "CPoint";
}

COpenGISType::OPENGIS_TYPE CPoint::getOGISType()const {
	return COpenGISType::OGIS_POINT;
}
bool CPoint::isSimple() const {
	return true;
}

bool CPoint::isEmpty() const {
	return mCoord->isEmpty();
}
std::ostream& operator<<(std::ostream& out, const CPoint& pt) {
	out << pt.getCoordinate();
	return out;
}

}
