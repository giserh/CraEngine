//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : PSDE
//  @ File Name : CPolygon.cpp
//  @ Date : 2010/12/20
//  @ Author : 
//
//


#include "CPolygon.h"

namespace Geometry {
CPolygon::CPolygon() {
	mShell = new CLinearRing();
	mHole = new vector<CGeometry *> ();
}

CPolygon::CPolygon(const CPolygon & poly) :
	CGeometry(poly) {
	mShell = new CLinearRing(*poly.mShell);
	mHole = new vector<CGeometry *> (poly.getNumHoles());
	for (size_t i = 0, n = poly.getNumHoles(); i < n; i++) {
		(*mHole)[i] = (CLinearRing*) (*poly.mHole)[i]->clone();
	}

}

CPolygon::CPolygon(CLinearRing* newShell, vector<CGeometry *> * newHole) {
	mShell = newShell;
	// some exception operations are required
	/*mHole = new vector<CGeometry *> ();
	 for (size_t i = 0, n = holes->size(); i < n; i++) {
	 mHole->push_back(holes[i]);
	 }*/
	mHole = newHole;
	if (!mShell)
		mShell = new CLinearRing();
	if (!mHole)
		mHole = new vector<CGeometry *> ();

}
CPolygon::~CPolygon() {

	delete mShell;
	if (mHole) {
		for (size_t i = 0, n = mHole->size(); i < n; i++) {
			delete (*mHole)[i];
		}
	}
	delete mHole;
}

CGeometry* CPolygon::clone() const {
	return new CPolygon(*this);
}
size_t CPolygon::getNumHoles() const {
	return mHole->size();
}
size_t CPolygon::getNumGeometries() const {
	return isEmpty() ? 0 : 1;
}
CLineString* CPolygon::getShell() const {
	return mShell;
}

CLineString* CPolygon::getHoleAt(size_t pos) const {
	return (CLineString*) (*mHole)[pos];
}

CCoVecSequence *CPolygon::getCoordinates() const {
	return mShell->getCoordinates();
}
double CPolygon::getArea() const {
	// to be done
	return 0.0;
}

double CPolygon::getLength() const {
	// to be done
	return 0.0;
}
size_t CPolygon::getNumPoints() const {
	size_t ans = mShell->getNumPoints();
	for (size_t i = 0, n = mHole->size(); i < n; i++) {
		ans += ((CLinearRing *) (*mHole)[i])->getNumPoints();
	}
	return ans;
}

CRectangle CPolygon::getBoundingRect()const{
	return mShell->getBoundingRect();
}
bool CPolygon::equalExact(CGeometry* geom, double eps) const {
	if (!isEquivalentClass(geom))
		return false;
	CPolygon *pOther = (CPolygon *) geom;
	if (getNumHoles() != pOther->getNumHoles())
		return false;
	if (!mShell->equalExact(pOther->mShell, eps))
		return false;
	for (size_t i = 0, n = mHole->size(); i < n; i++) {
		CLinearRing *pa = (CLinearRing *) (*mHole)[i];
		CLinearRing *pb = (CLinearRing *) ((*(pOther->mHole))[i]);
		if (!pa->equalExact(pb, eps))
			return false;
	}
	return true;
}


string CPolygon::getGeometryType() const {
	return "CPolygon";
}

bool CPolygon::isSimple() const {
	return true;
}

bool CPolygon::isEmpty() const {
	return mShell->isEmpty();
}
COpenGISType::OPENGIS_TYPE CPolygon::getOGISType() const {
	return COpenGISType::OGIS_POLYGON;
}
std::ostream &operator <<(std::ostream & out, const CPolygon &poly) {
	out << "shell " << *(poly.getShell()) << endl;
	out << "hole " << endl;
	for (size_t i = 0, n = poly.getNumHoles(); i < n; i++)
		out << i << "  " << *(poly.getHoleAt(i)) << endl;
	return out;
}

}
